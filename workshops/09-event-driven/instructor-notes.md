# 第9回 イベント駆動アーキテクチャ — 講師補助資料

## この回の核心

> 「非同期は強力だが複雑。結果整合性のトレードオフを理解する」

知識レベルA（実務経験必須）。概念が最も難しい回の1つ。CQRSとSagaは特に抽象度が高いため、図と具体例を多用する。

## 講師の事前準備チェックリスト

- [ ] メッセージブローカー（Kafka or RabbitMQ）を実務で使った経験を整理し、具体的なトラブル事例を2つ以上準備する
- [ ] 結果整合性で問題が発生したシナリオの実体験を1つ準備する
- [ ] CQRSの3レベルの違いを図で描き分けられるようにする
- [ ] Sagaパターンのコレオグラフィ/オーケストレーションの図を描けるようにする
- [ ] 冪等性の重要性をコード例で示せるようにする
- [ ] 第5回（ドメインイベント）、第7回（サービス間通信）との接続を整理する

## 時間配分ガイド

| パート | 配分 | 注意点 |
|--------|------|--------|
| 前回振り返り | 5分 | Docker/K8sの概念を確認 |
| イベント駆動とは | 15分 | コマンド vs イベントの違いを明確に |
| メッセージングの基盤 | 20分 | キュー vs ストリームの違い。冪等性 |
| **CQRS** | **25分** | 3レベルの図を描き分ける。全てに適用すべきでないことを強調 |
| **結果整合性とSaga** | **25分** | 補償トランザクションまで踏み込む |
| Node.jsでの実装 | 15分 | EventEmitter → Redis Pub/Sub → BullMQ |
| 休憩 | 10分 | |
| ディスカッション + Q&A | 20分 | |

## 各トピックの教え方のポイント

### コマンド vs イベント
- コマンド:「PlaceOrder（注文してください）」→ 命令、失敗しうる
- イベント:「OrderPlaced（注文が確定されました）」→ 事実、覆らない
- **命名規則の違い** を強調:コマンドは動詞の命令形、イベントは過去分詞形
- 第5回のドメインイベントがここで再登場することを明示

### メッセージキュー vs イベントストリーム
- **キュー（RabbitMQ/SQS）:** 1メッセージを1つのコンシューマーが処理。処理されたら消える
- **ストリーム（Kafka）:** イベントが永続化される。複数のコンシューマーがそれぞれ読む。再生可能
- 図を描いて「消えるメッセージ」と「残るイベント」の違いを視覚化する

### 冪等性
- **この回で最も実務的に重要な概念の1つ**
- 「同じイベントが2回届いても結果が同じ」ことの保証
- At-least-once delivery が主流 → 冪等な処理が必須
- コード例:処理済みイベントIDをDBに記録し、重複を検出

### CQRS
- **レベル1から順に説明する。** いきなりレベル3（データストア分離）から入ると混乱する
- レベル1:「コードの中でWriteとReadのパスを分ける」→ これだけでも十分な場合が多い
- レベル3:「Write用DBとRead用DBを分けて、イベントで同期する」→ 結果整合性が発生
- **問いかけ:** 「あなたのプロジェクトで、読み取りと書き込みの負荷差が大きいのはどこ？」
- **注意:** 「CQRSはすべてに適用すべきではない」を繰り返す

### 結果整合性
- 強い整合性:「書いた直後に読んだら必ず最新値が返る」
- 結果整合性:「いずれ最新値が反映される。タイムラグがある」
- ECサイトの例:「注文確定→在庫引当に数秒のラグがある」これが許容されるかはビジネス要件
- **CAP定理** は深入りしすぎない。「分散システムでは整合性と可用性の両方を完全には保てない」だけ伝える

### Sagaパターン
- READMEのコレオグラフィ/オーケストレーションの図をそのまま活用
- **補償トランザクション** が最も難しいポイント。「取り消す」のではなく「打ち消す操作を行う」
- 例:「決済が失敗したら、在庫引当を取り消す（在庫を戻す）」
- コレオグラフィ:シンプルだが全体のフローが見えにくい
- オーケストレーション:フローが明確だが中央集権的

## 想定される質問と回答例

| 質問 | 回答の方向性 |
|------|-------------|
| 「結果整合性はユーザーに不便では？」 | 「UI側での工夫（楽観的更新、ローディング表示、通知）で体験を補う。Amazonの注文確認メールも結果整合性」 |
| 「Kafkaを導入すべきタイミングは？」 | 「サービス間のイベント共有が必要で、かつイベントの永続化・再生が求められる場合。まずはRedis Pub/SubやBullMQで十分なケースが多い」 |
| 「CQRSとイベントソーシングはセット？」 | 「別物。CQRSだけ導入することが多い。イベントソーシングはさらに複雑さが増すので、強い理由がない限り導入しない」 |
| 「メッセージの順序はどう保証する？」 | 「Kafkaはパーティション内で順序保証。パーティションキーの設計が重要。RabbitMQは単一キュー内で順序保証」 |

## ディスカッションの注意点

「結果整合性の許容範囲」のテーマでは、参加者のプロジェクトによって感覚が大きく異なる。金融系は強い整合性を求め、ECやSNS系は結果整合性を許容しやすい。**正解はドメインで変わる** ことを示す。

## 次回（第10回 総合演習）への橋渡し

- 「9つのテーマの学習が今日で完了しました。次回は全テーマの知識を統合して、実際のシステム設計に取り組みます」
- 「次回はグループでアーキテクチャ設計を行います。今回までの各テーマの核心メッセージを振り返っておいてください」
- 「どのテーマも『なぜそれを選んだか』を説明できることが大事です」
